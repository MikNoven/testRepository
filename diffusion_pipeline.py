import os from os.path import abspathfrom datetime import datetimefrom nipype import Workflow, Node, MapNode, Functionfrom nipype.interfaces.fsl import TOPUP, ApplyTOPUP, BET, ExtractROI, Merge, Eddyimport nipype.interfaces.mrtrix3 as mrt#Set to relevant directorydatadir="/Users/ling-men/Documents/MRData/TonotopyDKI"#Load relevant files.os.chdir(datadir)#Convert to mif for the first time. N.B! Need newest version from dev for the number of shells to be allright.# Maybe check number of shells.mrconvert = mrt.MRConvert()mrconvert.inputs.in_file = 'DKI.nii.gz'mrconvert.inputs.grad_fsl = ('DKI.bvec', 'DKI.bval')mrconvert.inputs.out_file = 'DKI.mif'mrconvert.run()#DWI denoise. Doesn't do amazing difference but some at least. dwidenoise = mrt.DWIDenoise()dwidenoise.inputs.in_file = 'DKI.mif'dwidenoise.inputs.out_file = 'DKI_denoised.mif'dwidenoise.run()#Convert denoised back to NIfTImrconvert.inputs.in_file = 'DKI_denoised.mif'mrconvert.inputs.grad_fsl = ('DKI_denoised.bvec', 'DKI_denoised.bval')mrconvert.inputs.out_file = 'DKI_denoised.nii'mrconvert.run()#Use fieldmap to reduce B0 inhomogeneities#   Scanner gives mag and (wrapped) phase images in frequency offset (Hz)# Dwell time is the same as echo spacing. echo spacing in msec = 1000 * (water-fat shift (per pixel)/(water-fat shift (in Hz) * echo train length))# echo train length (etl) = EPI factor + 1# #Run topup to reduce epi-readout artefactsfslroi = ExtractROI(in_file='DKI_denoised.nii', roi_file='DKI_dn_nodif.nii', t_min=0, t_size=1)fslroi.run() #Generates FileNotFoundError but also an output so maybe no problem? fslmerge = Merge()fslmerge.inputs.in_files = ['DKI_revenc.nii.gz', 'DKI_dn_nodif.nii.gz']fslmerge.inputs.dimension = 't'fslmerge.inputs.merged_file = 'DKI_encfix.nii.gz'fslmerge.run()tpup = TOPUP() # --config=b02b0.cnf is deafult.tpup.inputs.in_file = 'DKI_encfix.nii.gz'tpup.inputs.encoding_file = 'acqparams.txt' #acqparams.txt is in the data foldertpup.inputs.out_base = 'DKI_topup_param'tpup.run()atpup = ApplyTOPUP()atpup.inputs.in_files = 'DKI_denoised.nii'atpup.inputs.encoding_file = 'acqparams.txt'atpup.inputs.in_index = [2]atpup.inputs.in_topup_fieldcoef = 'DKI_topup_param_fieldcoef.nii.gz'atpup.inputs.in_topup_movpar = 'DKI_topup_param_movpar.txt'atpup.inputs.method = 'jac'atpup.inputs.out_corrected = 'DKI_dn_topuped'atpup.run()#Get a good brain mask from b0fslroi = ExtractROI(in_file='DKI_dn_topuped.nii.gz', roi_file='DKI_dn_topuped_nodif.nii.gz', t_min=0, t_size=1)fslroi.run() bet = BET()bet.inputs.in_file = 'DKI_dn_topuped_nodif.nii.gz'bet.inputs.frac = 0.2bet.inputs.mask = Truebet.inputs.out_file = 'DKI_dn_topuped_nodif_brain.nii.gz'bet.run()#Run eddy for eddy current and motion correction#Index is the row in acqparam that describes the data, created before analysis#Had to patch in the eddy_cpu from fsl website and replace the old "eddy" with eddy_cpueddy = Eddy()eddy.inputs.in_file = 'DKI_dn_topuped.nii.gz'eddy.inputs.in_mask = 'DKI_dn_topuped_nodif_brain_mask.nii.gz'eddy.inputs.in_acqp = 'acqparams.txt' eddy.inputs.in_index = 'index.txt'eddy.inputs.in_bval = 'DKI.bval'eddy.inputs.in_bvec = 'DKI.bvec'eddy.inputs.in_topup_fieldcoef = 'DKI_topup_param_fieldcoef.nii.gz'eddy.inputs.in_topup_movpar = 'DKI_topup_param_movpar.txt'eddy.inputs.is_shelled = Trueeddy.inputs.num_threads = 6 #Possibly make this a settingeddy.inputs.out_base = 'DKI_dn_topuped_eddy'now = datetime.now() #Turn this into small functioncurrent_time = now.strftime("%H:%M:%S")print("Current Time =", current_time)eddy.run()now = datetime.now() #Turn this into small functioncurrent_time = now.strftime("%H:%M:%S")print("Current Time =", current_time)#Get DKI parameters from some software# E.g. DKE #Run tractography from MRTrix3#Convert to mifmrconvert = mrt.MRConvert()mrconvert.inputs.in_file = 'DKI_dn_topuped_mc.nii.gz'mrconvert.inputs.grad_fsl = ('DKI.bvec', 'DKI.bval')mrconvert.inputs.out_file = 'DKI_dn_topuped_mc.mif'mrconvert.run()#Maskmrconvert = mrt.MRConvert()mrconvert.inputs.in_file = 'DKI_dn_topuped_nodif_brain_mask.nii.gz'mrconvert.inputs.out_file = 'DKI_mask.mif'mrconvert.run()#dwi2response dhollander for possibility of FBA later# For now DKI_dn_topuped_mc.nii.gz but change to whatever the output of eddy is called.dtr = mrt.ResponseSD()dtr.inputs.in_file = 'DKI_dn_topuped_mc.mif'dtr.inputs.algorithm = 'dhollander'dtr.inputs.grad_fsl = ('DKI.bvec', 'DKI.bval')dtr.inputs.csf_file = 'DKI_csf.txt'dtr.inputs.gm_file = 'DKI_gm.txt'dtr.inputs.wm_file = 'DKI_wm.txt'dtr.inputs.nthreads = 6 #Possibly turn into a settingdtr.run()#dwi2fodfod = mrt.EstimateFOD()fod.inputs.algorithm = 'msmt_csd' fod.inputs.in_file = 'DKI_dn_topuped_mc.nii.gz'fod.inputs.grad_fsl = ('DKI.bvec', 'DKI.bval')fod.inputs.nthreads = 6 #Possibly turn into a settingfod.inputs.wm_txt = 'DKI_wm.txt'fod.inputs.wm_odf = 'DKI_wm_odf.mif'fod.inputs.gm_txt = 'DKI_gm.txt'fod.inputs.gm_odf = 'DKI_gm_odf.mif'fod.inputs.csf_txt = 'DKI_csf.txt'fod.inputs.csf_odf = 'DKI_csf_odf.mif'fod.inputs.mask_file = 'DKI_mask.mif'fod.inputs.max_sh = [8,8,8]; #Not extremely sure about this.fod.run()#tckgen#tckgen ${subj}_fod.mif ${subj}_tracks.tck -nthreads 6 -seed_image ${subj}_DTIbrainmask.nii.gz -mask ${subj}_DTIbrainmask.nii.gz -number 5000000tk = mrt.Tractography()tk.inputs.in_file = 'DKI_wm_odf.mif'tk.inputs.nthreads = 6 #Possibly turn into a settingtk.inputs.roi_mask = 'DKI_mask.mif'tk.inputs.seed_image = 'DKI_mask.mif'tk.inputs.select = 5000000 #Might have to be more.tk.inputs.out_file = 'DKI_tracks.tck'tk.run()#Run fixel-based analysis? 